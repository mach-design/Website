name: AI Implement from Issue

on:
  issue_comment:
    types: [created]

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  implement:
    if: contains(github.event.comment.body, '@claude') && contains(github.event.comment.body, 'implement')
    runs-on: ubuntu-latest

    steps:
      - name: Check out repo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install deps for script
        run: |
          npm --version
          mkdir -p scripts
          npm init -y
          npm install @anthropic-ai/sdk@latest @octokit/rest@20.1.1 glob@10.3.10

      - name: Write script to workspace
        run: |
          cat > scripts/ai_implement.mjs <<'EOF'
          import fs from 'node:fs';
          import path from 'node:path';
          import { glob } from 'glob';
          import Anthropic from '@anthropic-ai/sdk';
          import { Octokit } from '@octokit/rest';

          const {
            GITHUB_REPOSITORY,
            GITHUB_REF_NAME,
            GITHUB_SHA,
            GITHUB_EVENT_PATH,
            GITHUB_TOKEN,
            CLAUDE_MODEL = 'claude-3-7-sonnet-20250219',
            ANTHROPIC_API_KEY,
            MAX_CONTEXT_FILES = '200',
            MAX_FILE_BYTES = '40000',
          } = process.env;

          if (!ANTHROPIC_API_KEY) {
            console.error('Missing ANTHROPIC_API_KEY secret');
            process.exit(1);
          }

          const octokit = new Octokit({ auth: GITHUB_TOKEN });
          const [owner, repo] = GITHUB_REPOSITORY.split('/');

          const event = JSON.parse(fs.readFileSync(GITHUB_EVENT_PATH, 'utf8'));
          const issue = event.issue;
          const commentBody = event.comment?.body || '';

          async function listCandidateFiles() {
            const patterns = [
              '**/*.md',
              '**/*.html',
              '**/*.css',
              '**/*.js',
              '**/*.ts',
              '**/*.tsx',
              '**/*.jsx',
              '**/*.json',
              '!node_modules/**',
              '!.git/**',
              '!.next/**',
              '!dist/**',
              '!build/**',
              '!coverage/**',
            ];
            return glob(patterns, { dot: false, nodir: true, ignore: [] });
          }

          function safeRead(file) {
            try {
              const buf = fs.readFileSync(file);
              const max = parseInt(MAX_FILE_BYTES, 10);
              return buf.length <= max ? buf.toString('utf8') : null;
            } catch {
              return null;
            }
          }

          function buildRepoContext(files) {
            const maxFiles = parseInt(MAX_CONTEXT_FILES, 10);
            const out = [];
            for (const f of files) {
              if (out.length >= maxFiles) break;
              const content = safeRead(f);
              if (content !== null) {
                out.push({ path: f, content });
              }
            }
            return out;
          }

          const files = await listCandidateFiles();
          const repoContext = buildRepoContext(files);

          const system = `
          You are an expert software engineer acting as a careful code modifier.
          Return EXACTLY this JSON shape, and nothing else:
          {
            "title": "Short PR title",
            "summary": "One-paragraph PR description",
            "changes": [
              {
                "path": "relative/path.ext",
                "action": "create|update|delete",
                "content": "string (required for create/update; omit for delete)"
              }
            ]
          }
          Rules:
          - Only valid JSON. No code fences or commentary.
          - Keep changes minimal but complete.
          `;

          const user = {
            issue_number: issue.number,
            issue_title: issue.title,
            issue_body: issue.body,
            trigger_comment: commentBody,
            branch_base: GITHUB_REF_NAME || 'main',
            head_sha: GITHUB_SHA,
            repo_map: repoContext
          };

          const client = new Anthropic({ apiKey: ANTHROPIC_API_KEY });
          const completion = await client.messages.create({
            model: CLAUDE_MODEL,
            max_tokens: 3000,
            temperature: 0.2,
            system,
            messages: [
              {
                role: 'user',
                content: [
                  { type: 'text', text: `Issue + context:\n${JSON.stringify(user, null, 2)}` }
                ]
              }
            ]
          });

          const text = completion?.content?.[0]?.text?.trim() || '';
          let plan;
          try {
            plan = JSON.parse(text);
          } catch (e) {
            console.error('Claude returned invalid JSON:', text);
            process.exit(1);
          }

          const branchNameSafe = (plan.title || 'ai-change')
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/(^-|-$)/g, '');
          const branchName = `ai/${branchNameSafe}-${Date.now()}`;

          const baseRef = await (async () => {
            try {
              return await octokit.git.getRef({ owner, repo, ref: `heads/${user.branch_base}` });
            } catch {
              return await octokit.git.getRef({ owner, repo, ref: 'heads/main' });
            }
          })();

          await octokit.git.createRef({
            owner, repo,
            ref: `refs/heads/${branchName}`,
            sha: baseRef.data.object.sha
          });

          for (const ch of plan.changes) {
            const p = path.resolve(process.cwd(), ch.path);
            if (ch.action === 'delete') {
              if (fs.existsSync(p)) fs.rmSync(p, { recursive: true, force: true });
              continue;
            }
            if (['create', 'update'].includes(ch.action)) {
              if (typeof ch.content !== 'string') {
                console.error('Missing content for', ch.path);
                process.exit(1);
              }
              fs.mkdirSync(path.dirname(p), { recursive: true });
              fs.writeFileSync(p, ch.content, 'utf8');
            } else {
              console.error('Unknown action:', ch.action, 'for', ch.path);
              process.exit(1);
            }
          }

          const execSync = (await import('node:child_process')).execSync;
          execSync('git config user.name "github-actions[bot]"');
          execSync('git config user.email "41898282+github-actions[bot]@users.noreply.github.com
